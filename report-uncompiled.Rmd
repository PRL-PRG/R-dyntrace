---
title: "rivr (uncompiled)"
author: ""
date: "June 20, 2017"
output: html_document
---

<style>
  .col2 {
    columns: 2 200px;         /* number of columns and width in pixels*/
    -webkit-columns: 2 200px; /* chrome, safari */
    -moz-columns: 2 200px;    /* firefox */
  }
</style>

```{r apriori, include=FALSE}
path <- "rivr.uncompiled.sqlite"
```

```{r setup, include=FALSE}
library(dplyr)

db <- src_sqlite(path)

# tables
promises <- db %>% tbl("promises")
promise_evaluations <- db %>% tbl("promise_evaluations")
promise_associations <- db %>% tbl("promise_associations")
calls <- db %>% tbl("calls") %>% rename(call_id = id)
functions <- db %>% tbl("functions") %>% rename(function_id = id)
arguments <- db %>% tbl("arguments")

promise.forces <- promise_evaluations %>% filter(promise_id >= 0 && event_type == 15)
promise.lookups <- promise_evaluations %>% filter(promise_id >= 0 && event_type == 0)
alien.promise.forces <- promise_evaluations %>% filter(promise_id < 0 && event_type == 15)
```

## Basic information
``` {r basic, include=FALSE}
n.functions <- (functions %>% count %>% data.frame)$n
n.calls <- (calls %>% count %>% data.frame)$n
n.promises <- (promises %>% count %>% data.frame)$n
n.alien.promises <- (promise_evaluations %>% filter(promise_id < 0) %>% group_by(promise_id) %>% count %>% data.frame)$promise_id %>% length
n.promise.forces <- (promise.forces %>% count %>% data.frame)$n
n.promise.lookups <- (promise.lookups %>% count %>% data.frame)$n 
n.alien.promise.forces <- (alien.promise.forces %>% count %>% data.frame)$n
n.alien.promise.lookups <- NA # I currently don't collect this information to save space.
```

Functions: `r n.functions`  
Calls: `r n.calls`  
Promises: `r n.promises` (+ `r n.alien.promises` alien)  
Promise forces: `r n.promise.forces` (+ `r n.alien.promise.forces` alien)  
Promise lookups: `r n.promise.lookups` (+ `r n.alien.promise.lookups` alien)  

## Promises

Alien promises are promises which were created before we began tracing. We don't have all the information regarding them, so we generally ignore them, including in the data below. They also are a subject of a lot of lookups in functions from base::*, which we don't record to save disk space.

``` {r promises, include=FALSE}

get_lifestyles <- function() {
  lifestyles <-
    left_join(promises, promise.forces, by=c("id" = "promise_id"))  %>%
    mutate(lifestyle = ifelse(is.na(lifestyle), "virgin",
                       ifelse(lifestyle == 1, "local",
                       ifelse(lifestyle == 2, "branch-local",
                       ifelse(lifestyle == 3, "escaped",
                       ifelse(lifestyle == 4, "immediate local",
                       ifelse(lifestyle == 5, "immediate branch-local",
                                              "???"))))))) %>%
    select(id, from_call_id, in_call_id, lifestyle, effective_distance_from_origin) %>%
      
    group_by(lifestyle) %>% count(lifestyle) %>%
    mutate(percent=((n*100/n.promise.forces))) %>% rename(number = n) 
    #group_by(lifestyle) #%>%
    #do(mutate(., percent = paste(format(percent, digits=12), "%", sep="") ))
  
  all.lifestyles <- 
    data.frame(lifestyle = c("immediate local", "local", "immediate branch-local", "branch-local", "escaped", "virgin")) %>% 
    left_join(lifestyles, by="lifestyle", copy=TRUE) %>% 
    mutate(number = ifelse(is.na(number), 0, number), 
           percent = ifelse(is.na(percent), 0, percent))

  all.lifestyles %>% arrange(desc(number))
}

get_effective_distances <- function() {
  effective.distances <-
    left_join(promises, promise.forces, by=c("id" = "promise_id"))  %>%
    select(id, from_call_id, in_call_id, lifestyle, effective_distance_from_origin) %>%
      
    group_by(effective_distance_from_origin) %>% count %>%
    mutate(percent=((n*100/n.promise.forces))) %>% rename(number = n)
    #group_by(lifestyle) #%>%
    #do(mutate(., percent = paste(format(percent, digits=12), "%", sep="") ))
  
  na.distance <- NA
  min.distance <- -1
  max.distance <- 
    (effective.distances %>% filter(!is.na(effective_distance_from_origin)) %>% data.frame)$effective_distance_from_origin %>% 
    max
  distance.range <- c(na.distance, min.distance:max.distance)
  
  histogram <- 
    data.frame(effective_distance_from_origin = distance.range) %>% 
    left_join(effective.distances, by="effective_distance_from_origin", copy=TRUE) %>% 
    rename(effective_distance = effective_distance_from_origin)

  histogram
}

get_actual_distances <- function() {
  actual.distances <-
    left_join(promises, promise.forces, by=c("id" = "promise_id"))  %>%
    select(id, from_call_id, in_call_id, lifestyle, actual_distance_from_origin) %>%
      
    group_by(actual_distance_from_origin) %>% count %>%
    mutate(percent=((n*100/n.promise.forces))) %>% rename(number = n)
    #group_by(lifestyle) #%>%
    #do(mutate(., percent = paste(format(percent, digits=12), "%", sep="") ))
  
  na.distance <- NA
  min.distance <- -1
  max.distance <- 
    (actual.distances %>% filter(!is.na(actual_distance_from_origin)) %>% data.frame)$actual_distance_from_origin %>% 
    max
  distance.range <- c(na.distance, min.distance:max.distance)
  
  histogram <- 
    data.frame(actual_distance_from_origin = distance.range) %>% 
    left_join(actual.distances, by="actual_distance_from_origin", copy=TRUE) %>% 
    rename(actual_distance = actual_distance_from_origin)

  histogram
}

get_promise_types <- function(path="trace.sqlite") {
  promises %>% 
  #mutate(archetype = type*100+if(is.na(original_type)) 99 else original_type) %>%
  group_by(type, original_type) %>% count(type, original_type) %>% arrange(original_type, type) %>%
  mutate(percent=((n*100/n.promises))) %>%
  group_by(type, original_type) %>% 
  do(mutate(., 
            type_code = type, 
            type = humanize_promise_type(type, original_type), 
            #percent = paste(format(percent, digits=12),   "%", sep="")
            )) %>%
  rename(number=n) %>%
  group_by(type) %>% select(type, number, percent) %>%
  data.frame %>%   
  arrange(desc(number))
}

humanize_promise_type = function(type, fallback_type=NULL)
    if(is.na(type)) {
        if(is.null(fallback_type)) "NA"
        else paste("NA", Recall(fallback_type), sep=" ")
    } else
    if(type == 0) "NIL" else
    if(type == 1) "SYM" else
    if(type == 2) "LIST" else
    if(type == 3) "CLOS" else
    if(type == 4) "ENV" else
    if(type == 5) "PROM" else
    if(type == 6) "LANG" else
    if(type == 7) "SPECIAL" else
    if(type == 8) "BUILTIN" else
    if(type == 9) "CHAR" else
    if(type == 10) "LGL" else
    if(type == 13) "INT" else
    if(type == 14) "REAL" else
    if(type == 15) "CPLX" else
    if(type == 16) "STR" else
    if(type == 17) "DOT" else
    if(type == 18) "ANY" else
    if(type == 19) "VEC" else
    if(type == 20) "EXPR" else
    if(type == 21) {
      if(is.null(fallback_type)) "BCODE"
      else paste("BCODE", Recall(fallback_type), sep="->")
    } else
    if(type == 22) "EXTPTR" else
    if(type == 23) "WEAKREF" else
    if(type == 24) "RAW" else
    if(type == 25) "S4" else NULL

get_lookup_histogram <- function() {
 data <- promises %>% rename(promise_id = id) %>% left_join(promise.lookups, by="promise_id") %>% collect
 unevaluated <- data.frame(no.of.lookups=0, number=(data %>% filter(is.na(event_type)) %>% count %>% data.frame)$n)
 evaluated <- data %>% filter(!is.na(event_type)) %>% group_by(promise_id) %>% count %>% group_by(n) %>% count %>% rename(no.of.lookups=n, number=nn)
 unevaluated %>% union(evaluated)
}

get_force_histogram <- function() {
 data <- promises %>% rename(promise_id = id) %>% left_join(promise.forces, by="promise_id") %>% collect
 unevaluated <- data.frame(no.of.forces=0, number=(data %>% filter(is.na(event_type)) %>% count %>% data.frame)$n)
 evaluated <- data %>% filter(!is.na(event_type)) %>% group_by(promise_id) %>% count %>% group_by(n) %>% count %>% rename(no.of.forces=n, number=nn)
 unevaluated %>% union(evaluated)
}

```

### Promise evaluations
<div class="col2">
``` {r evaluations-print, echo=FALSE, , comment=""}
force.histogram <- get_force_histogram()
lookup.histogram <- get_lookup_histogram()
#force.histogram
#lookup.histogram

slices <- force.histogram$number
labels <- force.histogram$no.of.forces
par(mar=c(0,2,2,2))
pie(slices, labels, main="No. of forces")

labels <- lookup.histogram$no.of.lookups
values <- lookup.histogram$number
par(mar=c(2,2,2,2))
barplot(values, names.arg=labels, space=0, main="No. of lookups")
```
</div>

### Promise lifestyles



<div class="col2">
``` {r lifestyles-print, echo=FALSE, , comment="", warning=FALSE}
promise.lifestyles <- get_lifestyles()
promise.lifestyles
```

**immediate local** - evaluated in same call as it originated (effective distance = 0 and actual distance = 0)  
**local** - same, but passed to primitive or specials in origin (effective distance = 0, actual distance > 0)  
**immediate branch-local** - evaluated in a child call to its origin (effective distance = 1)  
**branch-local** - same, but further descendant  
**escaped** - evaluated in a call to which there is no path from its origin  
**virgin** - promise was never evaluated

``` {r lifestyles-pie, echo=FALSE, fig.width=6, fig.height=5}
slices <- (promise.lifestyles %>% arrange(number))$number
labels <- (promise.lifestyles %>% arrange(number) %>% mutate(lifestyle = ifelse(percent>1, lifestyle, "")))$lifestyle
par(mar=c(0,2,2,2))
pie(slices, labels, main="Promise lifestyles")
```
</div>

### Promise evaluation distances

Effective distance is the distance from the call where a promise originated to the call in which it was evaluated. It is measured along the call graph (along inbound edges).  Since the data is gathered from a trace, the call graph is a tree.

Special values:  
**NA** - promise was not executed, there is no distance measure (a virgin promise)  
**-1** - promise was executed but there is no path from the origin to the point of evaluation (an escaped promise)    
``` {r effective-distances, echo=FALSE, fig.width=12, fig.height=6}
histogram <- get_effective_distances()
labels <- histogram$effective_distance
values <- histogram$number
par(mar=c(2,2,2,2))
barplot(values, names.arg=labels, space=0, main="Effective distances")
```

``` {r actual-distances, echo=FALSE, fig.width=12, fig.height=6}
histogram <- get_actual_distances()
labels <- histogram$effective_distance
values <- histogram$number
par(mar=c(2,2,2,2))
barplot(values, names.arg=labels, space=0, main="Actual distances")
```

### Promise types

<div class="col2">
``` {r promise-types-print, echo=FALSE, comment=""}
promise.types <- get_promise_types()
promise.types
```

Promise types follow the type designations in``Rinternals.h``.  
**BCODE->α** indicates that it's a byte-compiled expression that was originally of type **α**.

``` {r promise-types-pie, echo=FALSE, fig.width=5, fig.height=4}
slices <- (promise.types %>% arrange(number))$number
labels <- (promise.types %>% arrange(number) %>% mutate(type = ifelse(percent>1, type, "")))$type
par(mar=c(0,2,2,2))
pie(slices, labels, main="Promise types")
```
</div>

## Functions and Calls

### Strictness



### Calls to specific functions

```{r function-calls, include=FALSE,}
get_function_calls <- function(...) {
  patterns <- list(...)
  
  data <- 
    left_join(functions, calls, by="function_id") %>% 
    select(function_name, function_id) %>% 
    #distinct(function_name, function_id) %>% 
    group_by(function_name, function_id) %>% count() %>% rename(number = n) %>%
    mutate(percent = ((number * 100) / n.calls)) %>%
    mutate(function_name = ifelse(is.na(function_name), "<anonymous>", function_name)) %>%
    select(function_id, function_name, number, percent) %>%
    collect(n=Inf)
  
  lapply(patterns, function(pattern) {filter(data, grepl(pattern, function_name))} ) %>% bind_rows
}
```

```{r function-calls-selected-counts, echo=FALSE, comment=""}
  get_function_calls("^<anonymous>$", "eval", "force", "delayAssign", "return") %>% data.frame
```




